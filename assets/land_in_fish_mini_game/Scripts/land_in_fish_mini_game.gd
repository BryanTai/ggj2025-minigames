### README -bryan 
# This Template script is intended to be a starting guide for making your own MiniGame
# COPY/PASTE the code into your own MiniGame script and add your logic
## DO NOT EDIT THIS FILE

## TL;DR What You Need To Do:
# 1) Create a new MiniGame scene and script
# 2A) If you're starting from scratch, copy/paste the contents of this file into your minigame script to get started
# 2B) If you're importing a game, make sure the top of your script has the "extends BaseMiniGame" line
# 3) Make sure _ready() and _process() have the "super()" call inside their bodies
# 4) Set the intro text with "instruction_text = "Replace me with instructions!" "
# 5) Trigger the Win and Lose with "trigger_game_lose()" and "trigger_game_win()"
# 6A) If the MiniGame has no logic that runs before or after the PLAYING state, add your code into _ready() and _process() as normal 
#	By default, the MiniGame will automatically disable all nodes at the beginning and enable them once the player has control
#	This can be disabled using the "disable_minigame_during_intro_and_outro" flag
# 6B) if you want the game to do stuff before the timer starts or after the game ends, read my notes about STATES below

## MINIGAME STATES
# There are 4 states that a Mini Game can be in:
#	1) PREPARING,	Game loads in, player has no control, instructions displayed
#	2) PLAYING, 	Player has control
#	3A) WIN, 		Player reaches the win condition, no longer has control
#	3B) LOSE, 		Either the player has reached a losing condition or has run out of time, no longer has control
## The MiniGame can only be in 1 state at a time
# See "BaseMiniGame.MiniGameState" and "BaseMiniGame.current_state"

## SWITCHING STATES
# Every State has an Event Function for Start, Process, and End
# The Process event for "current_state" will trigger every frame (similar to Unity's Update() function)
# When the "current_state" is changed from an old state to a new state, it will trigger the Start event of the new state
# On the same frame, the End event of the old state will also trigger
## BaseMiniGame and MiniGameManager will automatically handle switching states and TimeOuts
## New MiniGame scripts don't need to worry about implementing any of this

## STATE FUNCTIONS
# BaseMiniGame has functions for each state that are designed to be overridden:
# 	"_on_start_XXX_state"
# 	"_on_end_XXX_state"
# 	"_process_XXX_state"
## You can add your game logic into these functions (found at the bottom of this file) to limit which state they get called in
# By default, the MiniGame will disable all nodes during any state that isn't PLAYING
# as a result, you can use the _process() function as "_process_playing_state()" if you don't care about doing anything in PREPARING, WIN, or LOSE

## TRIGGERING WIN/LOSE
# There are two custom functions that will signal to the Manager that the game is over:
#	trigger_game_lose()
#	trigger_game_win()
## You need to add these functions into your minigame script for the game to end properly
# Additionally, the MiniGameManager will signal the MiniGame when the Timer runs out using this function:
#	_on_time_out()
# By default, this will trigger the LOSE state
## You can override this function if the MiniGame makes a check for win/lose at timeout

extends BaseMiniGame

@onready var bubs: Node2D = $Bubs

var canvas_x: float = 0
# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	instruction_text = "Land in the Fish Bucket!" # This text will display during the PREPARING phase
	super() ## Do not remove this super() call!
	## Put any logic you'd like to happen at the beginning of your minigame here!
	$Bubs/Area2D.area_entered.connect(_on_bubs_area_entered)
	$WindChangeTimer.timeout.connect(_on_wind_change_timer_timeout)
	_on_wind_change_timer_timeout() # Trgger the wind change initially.
	
	const EDGE_BUFFER_SIZE: float = 30 # pixels
	canvas_x = get_viewport().get_size().x
	$Bucket.position.x = randf_range(0 + EDGE_BUFFER_SIZE, canvas_x - EDGE_BUFFER_SIZE)

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta: float) -> void:
	super(delta) ## This line will process the State machine! DO NOT REMOVE
	## Use this _process function for your game logic!
	
	# Here's an example
	## TODO: Use these 2 functions to trigger WIN or LOSE
	#if(instruction_text == "Replace me with instructions!"):
		#trigger_game_lose()
	#else:
		#trigger_game_win()

func _on_bubs_area_entered(area: Area2D) -> void:
	print(area.name)
	if area.name == 'WinZone':
		return call_deferred("trigger_game_win")
	elif area.name == 'TippedZone':
		print("Bucket Tipped.")
	call_deferred("trigger_game_lose")
	pass

func _on_wind_change_timer_timeout() -> void:
	var tween = get_tree().create_tween()
	var new_wind_strenth = [1, -1].pick_random() * randf_range(0.5, 1)
	tween.tween_property(self, "wind_strength", new_wind_strenth, 0.4)
	tween.set_ease(Tween.EASE_IN_OUT)
	tween.set_trans(Tween.TRANS_CUBIC)
	tween.play()


# A signal from the MiniGameManager that time has run out
## TODO: Override this function if your MiniGame checks the win condition on TimeOut
#func _on_timeout() -> void:
#	trigger_game_lose()


### STATE SPECIFIC FUNCTIONS
# Add your game logic to these functions! See README at the top of this file for more info
# You probably won't need all of them so feel free to delete unused ones

## PREPARE STATE

# Called at the beginning of the game
#func _on_start_preparing_state() -> void:
#	# By default, this disables all Nodes in the minigame. Overwrite this if you want something else
#	pass

# Called every frame while minigame is in the PREPARING state
#func _process_preparing_state(delta: float) -> void:
#	pass

# Called once when the PREPARING state ends
#func _on_end_preparing_state() -> void:
#	# By default, this enables all disabled Nodes in the minigame
#	pass

## PLAYING STATE

# Called once when entering the PLAYING state (e.g. once the player gains control)
#func _on_start_playing_state() -> void:
#	pass

const FALL_SPEED: int = 200 # pixel per second
const SHUFFLE_SPEED: int = 300

var wind_strength: float = 0
const WIND_MAX_SPEED: int = 200
# Called every frame while minigame is in the PLAYING state
func _process_playing_state(delta: float) -> void:
	# Falling.
	bubs.position.y += 200 * delta
	
	# Moving Lef to Right.
	var direction := Input.get_axis("move_left", "move_right")
	# use keyboard/joystick input
	if(direction != 0):
		mouse_priority = false
	
	# use mouse_input
	if(direction == 0 and mouse_priority):
		direction = 1
		if target_x_pos < bubs.position.x:
			direction = -1
		if abs(target_x_pos - bubs.position.x) < mouse_x_buffer:
			direction = 0
	
	# Wind Influence.
	var wind_influence = wind_strength * WIND_MAX_SPEED * delta
	
	bubs.position.x += (direction * SHUFFLE_SPEED * delta) + wind_influence
	bubs.position.x = clamp(bubs.position.x, 0, canvas_x)
	

# Called once when the PLAYING state ends (e.g. Win or Lose)
#func _on_end_playing_state() -> void:
#	pass

## WIN STATE

 #Called once when entering the WIN state
func _on_start_win_state() -> void:
	$Bubs/BubsSprite.frame = 1
	pass

# Called every frame while minigame is in the WIN state
#func _process_win_state(delta: float) -> void:
#	pass

## LOSE STATE

# Called once when entering the LOSE state
func _on_start_lose_state() -> void:
	$Bubs/BubsSprite.frame = 2
	pass

# Called every frame while minigame is in the LOSE state
#func _process_lose_state(delta: float) -> void:
#	pass

var target_x_pos: float
var mouse_priority: bool = false
var mouse_x_buffer: float = 30.0

## Match the player to the mouse if mouse movement is detected
func _input(event):
	if event is InputEventMouseMotion:
		mouse_priority = true
		target_x_pos = event.position.x
