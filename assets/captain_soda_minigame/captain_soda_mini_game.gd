### README -bryan 
# This Template script is intended to be a starting guide for making your own MiniGame
# COPY/PASTE the code into your own MiniGame script and add your logic
## DO NOT EDIT THIS FILE

## TL;DR What You Need To Do:
# 1) Create a new MiniGame scene and script
# 2A) If you're starting from scratch, copy/paste the contents of this file into your minigame script to get started
# 2B) If you're importing a game, make sure the top of your script has the "extends BaseMiniGame" line
# 3) Make sure _ready() and _process() have the "super()" call inside their bodies
# 4) Set the intro text with "instruction_text = "Replace me with instructions!" "
# 5) Trigger the Win and Lose with "trigger_game_lose()" and "trigger_game_win()"
# 6A) If the MiniGame has no logic that runs before or after the PLAYING state, add your code into _ready() and _process() as normal 
#	By default, the MiniGame will automatically disable all nodes at the beginning and enable them once the player has control
#	This can be disabled using the "disable_minigame_during_intro_and_outro" flag
# 6B) if you want the game to do stuff before the timer starts or after the game ends, read my notes about STATES below

## MINIGAME STATES
# There are 4 states that a Mini Game can be in:
#	1) PREPARING,	Game loads in, player has no control, instructions displayed
#	2) PLAYING, 	Player has control
#	3A) WIN, 		Player reaches the win condition, no longer has control
#	3B) LOSE, 		Either the player has reached a losing condition or has run out of time, no longer has control
## The MiniGame can only be in 1 state at a time
# See "BaseMiniGame.MiniGameState" and "BaseMiniGame.current_state"

## SWITCHING STATES
# Every State has an Event Function for Start, Process, and End
# The Process event for "current_state" will trigger every frame (similar to Unity's Update() function)
# When the "current_state" is changed from an old state to a new state, it will trigger the Start event of the new state
# On the same frame, the End event of the old state will also trigger
## BaseMiniGame and MiniGameManager will automatically handle switching states and TimeOuts
## New MiniGame scripts don't need to worry about implementing any of this

## STATE FUNCTIONS
# BaseMiniGame has functions for each state that are designed to be overridden:
# 	"_on_start_XXX_state"
# 	"_on_end_XXX_state"
# 	"_process_XXX_state"
## You can add your game logic into these functions (found at the bottom of this file) to limit which state they get called in
# By default, the MiniGame will disable all nodes during any state that isn't PLAYING
# as a result, you can use the _process() function as "_process_playing_state()" if you don't care about doing anything in PREPARING, WIN, or LOSE

## TRIGGERING WIN/LOSE
# There are two custom functions that will signal to the Manager that the game is over:
#	trigger_game_lose()
#	trigger_game_win()
## You need to add these functions into your minigame script for the game to end properly
# Additionally, the MiniGameManager will signal the MiniGame when the Timer runs out using this function:
#	_on_time_out()
# By default, this will trigger the LOSE state
## You can override this function if the MiniGame makes a check for win/lose at timeout

extends BaseMiniGame

# Instantiate
var rng = RandomNumberGenerator.new()

# Parameters
var rotation_lerp_speed = 0.05
var gun_sound_list = [
	preload("res://assets/captain_soda_minigame/sfx bubble pop 1.wav"),
	preload("res://assets/captain_soda_minigame/sfx bubble pop 2.wav"),
	preload("res://assets/captain_soda_minigame/sfx bubble pop 3.wav"),
	preload("res://assets/captain_soda_minigame/sfx bubble pop 4.wav"),
	preload("res://assets/captain_soda_minigame/sfx bubble pop 5.wav")
]
var enemies_to_spawn = randi_range(3, 7)
var enemy_death_sounds = [
	preload("res://assets/captain_soda_minigame/sfx enemy bomb 2.wav"),
	preload("res://assets/captain_soda_minigame/sfx enemy die 1.wav")
]

# Object assets
var obj_Enemy 	= preload("res://assets/captain_soda_minigame/CaptainSoda_Enemy.tscn")
var obj_bullet 	= preload("res://assets/captain_soda_minigame/CaptainSoda_Bullet.tscn")

# Nodes
@onready var captain_soda: Node2D 					= $CaptainSoda
@onready var gun_sound: AudioStreamPlayer 			= $CaptainSoda/GunSound
@onready var captain_soda_music: AudioStreamPlayer 	= $CaptainSodaMusic
@onready var projectiles: Node2D 					= $Projectiles
@onready var enemies: Node2D = $Enemies
@onready var enemy_death: AudioStreamPlayer = $EnemyDeath



var _mouse_target_pos = null
func _input(event):
	if event is InputEventMouseMotion:
		_mouse_target_pos = event.position
		#print("Mouse Position: " + str(_mouse_target_pos))



# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	instruction_text = "SHOOT!" # This text will display during the PREPARING phase
	disable_minigame_during_intro_and_outro = false
	super() ## Do not remove this super() call!
	## Put any logic you'd like to happen at the beginning of your minigame here!
	
	
	# Randomize music track start position
	# Randomly choose either to play the music or the game intro
	if rng.randf() <= 0.75:
		var _track_length = captain_soda_music.stream.get_length()
		captain_soda_music.seek(_track_length * randf())
	else:
		captain_soda_music.stream = load("res://assets/captain_soda_minigame/Captain_Soda_-_TItle_Screen_-_v1.2_DEMO_legal_sfx.wav")
		captain_soda_music.play()
		pass

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta: float) -> void:
	super(delta) ## This line will process the State machine! DO NOT REMOVE
	
	#check if win state is achieved
	if enemies.get_child_count() < 1 and current_state == MiniGameState.PLAYING:
		trigger_game_win()
	
	# Favor keyboard over mouse
	var _target_angle = null
	var direction := Vector2(Input.get_axis("move_left", "move_right"), 0.0)
	if direction:
		_mouse_target_pos = null
		#print("keyboard direction: " + str(direction))
		_target_angle = rad_to_deg(captain_soda.rotation) + 45*direction.x
		#print("keyboard angle: " + str(_target_angle))
	elif _mouse_target_pos != null:
		_target_angle = rad_to_deg(captain_soda.position.direction_to(_mouse_target_pos).angle())
		#print("Mouse angle: " + str(_target_angle))
		pass
		
	
	
	
	# Rotate gun
	if _target_angle != null:
		var _aim_angle = lerp_angle(captain_soda.rotation, deg_to_rad(_target_angle), rotation_lerp_speed)
		captain_soda.rotation = _aim_angle
		
		# Set gun flip
		var _angle_flip_check = fmod(abs(rad_to_deg(captain_soda.rotation)), 360.0)
		if _angle_flip_check > 90.0 && _angle_flip_check < 270.0:
			captain_soda.scale.y = -1
		else:
			captain_soda.scale.y = 1

	# shoot bubbles on press
	if Input.is_action_just_pressed("fire"):
		var _bullet = obj_bullet.instantiate()
		projectiles.add_child(_bullet)
		_bullet.global_position = captain_soda.get_node("Sprite2D").global_position
		_bullet.move_angle = captain_soda.rotation
		gun_sound.stream = gun_sound_list.pick_random()
		gun_sound.play()

func on_enemy_dead(enemy_name):
	if enemy_name == "Bomb":
		enemy_death.stream = enemy_death_sounds[0]
	else:
		enemy_death.stream = enemy_death_sounds[1]
	enemy_death.play()
	
## PREPARE STATE

func _on_start_preparing_state() -> void:
	# Spawn a random amount of enemies on random positions
	for enemy_index in enemies_to_spawn:
		# Spawn enemy
		var _enemy = obj_Enemy.instantiate()
		enemies.add_child(_enemy)
		_enemy.connect("enemy_died", on_enemy_dead)
		
		# Position enemy in room
		# Make sure they're at least a distance away from the player
		var _min_spawn_distance = 150
		var _spawn_position = null
		while _spawn_position == null:
			var _new_spawn_pos = Vector2(randf_range(100, 900), randf_range(100, 900))
			var _distance_to_player = _new_spawn_pos.distance_to(captain_soda.global_position)
			
			if _distance_to_player >= _min_spawn_distance:
				_spawn_position = _new_spawn_pos
		
		_enemy.global_position = _spawn_position

func _on_end_playing_state() -> void:
	captain_soda_music.stop()
